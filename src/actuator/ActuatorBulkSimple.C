// Copyright 2017 National Technology & Engineering Solutions of Sandia, LLC
// (NTESS), National Renewable Energy Laboratory, University of Texas Austin,
// Northwest Research Associates. Under the terms of Contract DE-NA0003525
// with NTESS, the U.S. Government retains certain rights in this software.
//
// This software is released under the BSD 3-clause license. See LICENSE file
// for more details.
//

#include <actuator/ActuatorBulkSimple.h>
#include <actuator/UtilitiesActuator.h>
#include <NaluEnv.h>

namespace sierra {
namespace nalu {

ActuatorMetaSimple::ActuatorMetaSimple(const ActuatorMeta& actMeta)
  : ActuatorMeta(actMeta),
    turbineNames_(numberOfActuators_),
    turbineOutputFileNames_(numberOfActuators_),
    filterLiftLineCorrection_(false),
    isotropicGaussian_(false),
    maxNumPntsPerBlade_(0),
    epsilon_("epsilonMeta", numberOfActuators_),
    epsilonChord_("epsilonChordMeta", numberOfActuators_),
    epsilonTower_("epsilonTowerMeta", numberOfActuators_),
    useUniformAziSampling_(
      "diskUseUniSample", is_disk() ? numberOfActuators_ : 0),
    nPointsSwept_("diskNumSwept", is_disk() ? numberOfActuators_ : 0),
    nBlades_("numTurbBlades", numberOfActuators_),
    num_force_pts_blade_("numForcePtsBladeMeta", numberOfActuators_),
    p1_("p1Meta", numberOfActuators_),
    p2_("p2Meta", numberOfActuators_),
    p1zeroalphadir_("p1zeroalphadirMeta", numberOfActuators_),
    chordnormaldir_("chordnormaldirMeta", numberOfActuators_),
    spandir_("spandirMeta", numberOfActuators_)

{
}

  /* // LCCDELETE
int
ActuatorMetaSimple::get_fast_index(
  fast::ActuatorNodeType type, int turbId, int index, int bladeNum) const
{
  return actuator_utils::get_fast_point_index(
    fastInputs_, turbId, nBlades_(turbId), type, index, bladeNum);
}
  */

bool
ActuatorMetaSimple::is_disk()
{
  return false; // actuatorType_ == ActuatorType::ActDiskFASTNGP;
}

ActuatorBulkSimple::ActuatorBulkSimple(
  const ActuatorMetaSimple& actMeta, double naluTimeStep)
  : ActuatorBulk(actMeta),
    turbineThrust_("turbineThrust", actMeta.numberOfActuators_),
    turbineTorque_("turbineTorque", actMeta.numberOfActuators_),
    hubLocations_("hubLocations", actMeta.numberOfActuators_),
    hubOrientation_("hubOrientations", actMeta.numberOfActuators_),
    epsilonOpt_("epsilonOptimal", actMeta.numPointsTotal_),
    orientationTensor_(
      "orientationTensor",
      actMeta.isotropicGaussian_ ? 0 : actMeta.numPointsTotal_),
    num_force_pts_blade_("numForcePtsBladeBulk", actMeta.numberOfActuators_),
    num_blades_(actMeta.numberOfActuators_),
    debug_output_(actMeta.debug_output_),
    assignedProc_("assignedProcBulk", actMeta.numberOfActuators_),
    localTurbineId_(// NaluEnv::self().parallel_rank()),
      NaluEnv::self().parallel_rank() >= actMeta.numberOfActuators_
        ? -1
      : NaluEnv::self().parallel_rank()) // assign 1 turbine per rank for now Used to be ? -1
  //tStepRatio_(naluTimeStep / actMeta.fastInputs_.dtFAST) // LCCDELETE
{
  //init_openfast(actMeta, naluTimeStep);
  // Allocate blades to turbines
  const int nProcs = NaluEnv::self().parallel_size();
  const int nTurb = actMeta.numberOfActuators_;
  const int intDivision = nTurb / nProcs;
  const int remainder = actMeta.numberOfActuators_ % nProcs;

  NaluEnv::self().naluOutputP0() << " nProcs: " << nProcs 
				 << " nTurb:  " << nTurb
				 << " intDiv: " << intDivision
				 << " remain: " << remainder
				 << std::endl; // LCCOUT

  if (remainder && intDivision)  // this doesn't work for nProcs=1
    throw std::runtime_error(" ERRORXX: more blades than ranks");
  if (nTurb > nProcs) 
    throw std::runtime_error(" ERROR: more blades than ranks");

  for (int i=0; i<nTurb; i++) {
    assignedProc_.h_view(i) = i;
    NaluEnv::self().naluOutputP0() << " Turbine#: " << i
				   << " Proc#: " << assignedProc_.h_view(i) <<std::endl;

  }

  /*
  for (int i = 0; i < intDivision; i++) {
    for (int j = 0; j < nProcs; j++) {
      NaluEnv::self().naluOutputP0() << " Turbine#: " << j + i * nProcs
				     << " Proc#: " << j <<std::endl;
    }
  }
  */
  

  // Set up num_force_pts_blade_
  for (int i = 0; i <actMeta.numberOfActuators_; ++i) {
    num_force_pts_blade_.h_view(i) = actMeta.num_force_pts_blade_.h_view(i);
  }
  // Double check offsets
  if (actMeta.debug_output_) 
    for (int i = 0; i <actMeta.numberOfActuators_; ++i) {
      NaluEnv::self().naluOutputP0() << "Offset blade: " << i << " "
				     << turbIdOffset_.h_view(i) 
				     << " num_force_pts: "
				     << num_force_pts_blade_.h_view(i)
				     << std::endl; //LCCOUT
    }
  init_epsilon(actMeta);
  NaluEnv::self().naluOutputP0() << "Done ActuatorBulkSimple Init "
				 << std::endl; // LCCOUT
  // throw std::runtime_error("ActuatorBulkSimple: start");  // LCCSTOP
}

ActuatorBulkSimple::~ActuatorBulkSimple() { 
  // openFast_.end();  // LCCDELETE
}
  /*  
void
ActuatorBulkSimple::init_openfast(
  const ActuatorMetaSimple& actMeta, double naluTimeStep)
{
  // openFast_.setInputs(actMeta.fastInputs_); //LCCDELETE

  //LCCDELETE
  if (
    std::abs(naluTimeStep - tStepRatio_ * actMeta.fastInputs_.dtFAST) <
    0.001) { // TODO: Fix
    // arbitrary number
    // 0.001
    NaluEnv::self().naluOutputP0()
      << "Time step ratio  dtNalu/dtFAST: " << tStepRatio_ << std::endl;
  } else {
    throw std::runtime_error("ActuatorFAST: Ratio of Nalu's time step is not "
                             "an integral multiple of FAST time step");
  }

  const int nProcs = NaluEnv::self().parallel_size();
  const int nTurb = actMeta.numberOfActuators_;
  const int intDivision = nTurb / nProcs;
  const int remainder = actMeta.numberOfActuators_ % nProcs;
  const int nOffset = intDivision * nProcs;

  ThrowErrorMsgIf(
    remainder && intDivision,
    "nalu-wind can't process more turbines than ranks.");

  // assign turbines to processors uniformly
  for (int i = 0; i < intDivision; i++) {
    for (int j = 0; j < nProcs; j++) {
      openFast_.setTurbineProcNo(j + i * nProcs, j);
    }
  }
  //LCCDELETE
  for (int i = 0; i < remainder; i++) {
    openFast_.setTurbineProcNo(i + nOffset, i);
  }

  if(actMeta.fastInputs_.debug){
    openFast_.init();
  }
  else{
    squash_simple_output(std::bind(&fast::OpenFAST::init, &openFast_));
  }
  
  for (int i = 0; i < nTurb; ++i) {
    if (localTurbineId_ == openFast_.get_procNo(i)) {
      ThrowErrorMsgIf(
        actMeta.nBlades_(i) != openFast_.get_numBlades(i),
        "Mismatch in number of blades between OpenFAST and input deck."
        " InputDeck: " +
          std::to_string(actMeta.nBlades_(i)) +
          " OpenFAST: " + std::to_string(openFast_.get_numBlades(i)));
    }
  }
}
  */  //LCCDELETE

void
ActuatorBulkSimple::init_epsilon(const ActuatorMetaSimple& actMeta)
{
  // set epsilon and radius

  epsilon_.modify_host();
  epsilonOpt_.modify_host();
  searchRadius_.modify_host();

  const int nBlades = actMeta.n_simpleblades_;
  for (int iBlade = 0; iBlade<nBlades; iBlade++) {
    // LCC test this for non-isotropic
    if (NaluEnv::self().parallel_rank()==assignedProc_.h_view(iBlade)) { 
      const int numForcePts = actMeta.num_force_pts_blade_.h_view(iBlade);
      const int offset = turbIdOffset_.h_view(iBlade);      
      auto epsilonChord =
        Kokkos::subview(actMeta.epsilonChord_.view_host(), iBlade, Kokkos::ALL);
      auto epsilonRef =
        Kokkos::subview(actMeta.epsilon_.view_host(), iBlade, Kokkos::ALL);
      for (int np = 0; np < numForcePts; np++) {
        auto epsilonLocal =
          Kokkos::subview(epsilon_.view_host(), np + offset, Kokkos::ALL);
        auto epsilonOpt =
          Kokkos::subview(epsilonOpt_.view_host(), np + offset, Kokkos::ALL);

	double chord = actMeta.chord_table_[iBlade][np];
	for (int i = 0; i < 3; i++) {
	  // Define the optimal epsilon
	  epsilonOpt(i) = epsilonChord(i) * chord;
	  epsilonLocal(i) = std::max(epsilonOpt(i), epsilonRef(i));
	}
        // The radius of the searching. This is given in terms of
        //   the maximum of epsilon.x/y/z/.
        //
        // This is the length where the value of the Gaussian becomes
        // 0.1 % (1.0 / .001 = 1000) of the value at the center of the Gaussian
        searchRadius_.h_view(np + offset) =
          std::max(
            epsilonLocal(0), std::max(epsilonLocal(1), epsilonLocal(2))) *
          sqrt(log(1.e3));

      } // loop over np
    }
  } // loop over iBlade

  // DELETE THIS STUFF LATER
  /*
  bool INCLUDEFASTSTUFF=false;
  if (INCLUDEFASTSTUFF) {
  const int nTurb = openFast_.get_nTurbinesGlob();
  for (int iTurb = 0; iTurb < nTurb; iTurb++) {
    if (openFast_.get_procNo(iTurb) == NaluEnv::self().parallel_rank()) {
      ThrowAssert(actMeta.numPointsTotal_ >= openFast_.get_numForcePts(iTurb));
      const int numForcePts = openFast_.get_numForcePts(iTurb);
      const int offset = turbIdOffset_.h_view(iTurb);
      auto epsilonChord =
        Kokkos::subview(actMeta.epsilonChord_.view_host(), iTurb, Kokkos::ALL);
      auto epsilonRef =
        Kokkos::subview(actMeta.epsilon_.view_host(), iTurb, Kokkos::ALL);
      auto epsilonTower =
        Kokkos::subview(actMeta.epsilonTower_.view_host(), iTurb, Kokkos::ALL);

      for (int np = 0; np < numForcePts; np++) {

        auto epsilonLocal =
          Kokkos::subview(epsilon_.view_host(), np + offset, Kokkos::ALL);
        auto epsilonOpt =
          Kokkos::subview(epsilonOpt_.view_host(), np + offset, Kokkos::ALL);

        switch (openFast_.getForceNodeType(iTurb, np)) {
        case fast::HUB: {
          float nac_cd = openFast_.get_nacelleCd(iTurb);
          // Compute epsilon only if drag coefficient is greater than zero
          if (nac_cd > 0) {
            float nac_area = openFast_.get_nacelleArea(iTurb);

            // This model is used to set the momentum thickness
            // of the wake (Martinez-Tossas PhD Thesis 2017)
            float tmpEps = std::sqrt(2.0 / M_PI * nac_cd * nac_area);
            for (int i = 0; i < 3; i++) {
              epsilonLocal(i) = tmpEps;
            }
          }
          // If no nacelle force just specify the standard value
          // (it will not be used)
          else {
            for (int i = 0; i < 3; i++) {
              epsilonLocal(i) = epsilonRef(i);
            }
          }
          for (int i = 0; i < 3; i++) {
            epsilonOpt(i) = epsilonLocal(i);
          }
          break;
        }
        case fast::BLADE: {
          double chord = openFast_.getChord(np, iTurb);
          for (int i = 0; i < 3; i++) {
            // Define the optimal epsilon
            epsilonOpt(i) = epsilonChord(i) * chord;
            epsilonLocal(i) = std::max(epsilonOpt(i), epsilonRef(i));
          }
          break;
        }
        case fast::TOWER: {
          for (int i = 0; i < 3; i++) {
            epsilonLocal(i) = epsilonTower(i);
            epsilonOpt(i) = epsilonLocal(i);
          }
          break;
        }
        default:
          throw std::runtime_error("Actuator line model node type not valid");
          break;
        }

        for (int i = 0; i < 3; ++i) {
          ThrowAssertMsg(
            epsilonLocal(i) > 0.0,
            "Epsilon zero for point: " + std::to_string(np) + " index " +
              std::to_string(i));
        }

        // The radius of the searching. This is given in terms of
        //   the maximum of epsilon.x/y/z/.
        //
        // This is the length where the value of the Gaussian becomes
        // 0.1 % (1.0 / .001 = 1000) of the value at the center of the Gaussian
        searchRadius_.h_view(np + offset) =
          std::max(
            epsilonLocal(0), std::max(epsilonLocal(1), epsilonLocal(2))) *
          sqrt(log(1.e3));
      }
    } else {
      NaluEnv::self().naluOutput() << "Proc " << NaluEnv::self().parallel_rank()
                                   << " glob iTurb " << iTurb << std::endl;
    }
  }
  } // INCLUDEFASTSTUFF
  */
  actuator_utils::reduce_view_on_host(epsilon_.view_host());
  actuator_utils::reduce_view_on_host(epsilonOpt_.view_host());
  actuator_utils::reduce_view_on_host(searchRadius_.view_host());
  epsilon_.sync_host();
  epsilonOpt_.sync_host();
  searchRadius_.sync_host();
}

Kokkos::RangePolicy<ActuatorFixedExecutionSpace>
ActuatorBulkSimple::local_range_policy()
{
  auto rank = NaluEnv::self().parallel_rank();
  //if (rank == openFast_.get_procNo(rank)) { //LCCDELETE
  if (rank < num_blades_) {
    const int offset = turbIdOffset_.h_view(rank);
    const int size = num_force_pts_blade_.h_view(rank); //openFast_.get_numForcePts(rank);
    return Kokkos::RangePolicy<ActuatorFixedExecutionSpace>(
      offset, offset + size);
  } else {
    return Kokkos::RangePolicy<ActuatorFixedExecutionSpace>(0, 0);
  }
}

  //LCCDELETE
  /*
void
ActuatorBulkSimple::interpolate_velocities_to_fast()
{
  openFast_.interpolateVel_ForceToVelNodes();

  if (openFast_.isTimeZero()) {
    if(openFast_.isDebug()){
      openFast_.solution0();
    }
    else{
      squash_simple_output(std::bind(&fast::OpenFAST::solution0, &openFast_));
    }
  }
}
  */  //LCCDELETE

/*  //LCCDELETE
void
ActuatorBulkSimple::step_fast()
{
  if(openFast_.isDebug()){
    for (int j = 0; j < tStepRatio_; j++) {
      openFast_.step();
    }
  }
  else{
    for (int j = 0; j < tStepRatio_; j++) {
      squash_simple_output(std::bind(&fast::OpenFAST::step, &openFast_));
    }
  }
}
*/  //LCCDELETE

/*  //LCCDELETE
bool
ActuatorBulkSimple::fast_is_time_zero()
{
  int localFastZero = (int)openFast_.isTimeZero();
  int globalFastZero = 0;
  MPI_Allreduce(
    &localFastZero, &globalFastZero, 1, MPI_INT, MPI_SUM,
    NaluEnv::self().parallel_comm());
  return globalFastZero > 0;
}
*/  //LCCDELETE


void
ActuatorBulkSimple::output_torque_info()
{
  for (size_t iTurb = 0; iTurb < turbineThrust_.extent(0); iTurb++) {

    //int processorId = openFast_.get_procNo(iTurb);
    //if (NaluEnv::self().parallel_rank() == processorId) {
    if (NaluEnv::self().parallel_rank() == iTurb) {
      auto thrust = Kokkos::subview(turbineThrust_, iTurb, Kokkos::ALL);
      auto torque = Kokkos::subview(turbineTorque_, iTurb, Kokkos::ALL);
      NaluEnv::self().naluOutput()
        << std::endl
        << "  Thrust[" << iTurb << "] = " << thrust(0) << " " << thrust(1)
        << " " << thrust(2) << " " << std::endl;
      // NaluEnv::self().naluOutput()
      //   << "  Torque[" << iTurb << "] = " << torque(0) << " " << torque(1)
      //   << " " << torque(2) << " " << std::endl;

      /*
      std::vector<double> tmpThrust(3);
      std::vector<double> tmpTorque(3);

      openFast_.computeTorqueThrust(iTurb, tmpTorque, tmpThrust);

      NaluEnv::self().naluOutput()
        << "  Thrust ratio actual/correct = [" << thrust(0) / tmpThrust[0]
        << " " << thrust(1) / tmpThrust[1] << " " << thrust(2) / tmpThrust[2]
        << "] " << std::endl;
      NaluEnv::self().naluOutput()
        << "  Torque ratio actual/correct = [" << torque(0) / tmpTorque[0]
        << " " << torque(1) / tmpTorque[1] << " " << torque(2) / tmpTorque[2]
        << "] " << std::endl;
      */
    }
  }
}

void
ActuatorBulkSimple::zero_open_fast_views()
{
  dvHelper_.touch_dual_view(actuatorForce_);
  dvHelper_.touch_dual_view(pointCentroid_);
  dvHelper_.touch_dual_view(velocity_);
  Kokkos::deep_copy(dvHelper_.get_local_view(actuatorForce_),0.0);
  Kokkos::deep_copy(dvHelper_.get_local_view(pointCentroid_),0.0);
  Kokkos::deep_copy(dvHelper_.get_local_view(velocity_),0.0);
  //NaluEnv::self().naluOutput() << "Done zero_open_fast_views()"<<std::endl;//LCCOUT
     
}

} // namespace nalu
} // namespace sierra
